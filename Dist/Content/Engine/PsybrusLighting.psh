#ifndef __PSYBRUSLIGHTING_PSH__
#define __PSYBRUSLIGHTING_PSH__

// Generated header.
#include <UniformLight.psh>

#define USE_SPECULAR_BLINN_PHONG ( 0 )
#define USE_SPECULAR_GGX ( 1 )
#define USE_DIFFUSE_LAMBERT ( 1 )

#define LIGHTING_EPSILON  ( 1e-6 )
#define DIELECTRIC_F0 ( 0.04 )

//////////////////////////////////////////////////////////////////////////
// Light
struct Light
{
	float3 Position_;
	float3 Colour_;
	float3 AttenuationCLQ_;
};

//////////////////////////////////////////////////////////////////////////
// Material
struct Material
{
	float3 Colour_;
	float Roughness_;
	float Metallic_;
};

//////////////////////////////////////////////////////////////////////////
// Pow5
float Pow5( float Val )
{
	return Val * Val * Val * Val * Val;
}

//////////////////////////////////////////////////////////////////////////
// calculateAttenuation
float calculateAttenuation( float Distance, float3 Attenuation )
{
	float InvA = ( ( Attenuation.x + ( Distance * Attenuation.y ) + ( Distance * Distance * Attenuation.z ) ) );
	return 1.0 / InvA;
}

//////////////////////////////////////////////////////////////////////////
// RoughnessToSpecularPower
float RoughnessToSpecularPower( float Roughness )
{
	return 1024.0 * Pow5( 1.0 - Roughness ) + 1.0;
}

//////////////////////////////////////////////////////////////////////////
// Fresnel_SchlickApproximation

float3 Fresnel_SchlickApproximation( float3 F0, float CosA )
{
	float Pow5OneMinusCosA = Pow5( 1.0 - CosA );
	return F0 + ( float3( 1.0, 1.0, 1.0 ) - F0 ) * Pow5OneMinusCosA;
}

//////////////////////////////////////////////////////////////////////////
// NDF_BlinnPhongNormalised
// Equation 19: https://dl.dropboxusercontent.com/u/55891920/papers/mm_brdf.pdf
float NDF_BlinnPhongNormalised( float NdotH, float N )
{
	float NormTerm = ( N + 2.0 ) / ( PIMUL2 );
	float SpecTerm = pow( max( 0.0, NdotH ), N );
	return NormTerm * SpecTerm;
}
//////////////////////////////////////////////////////////////////////////
// NDF_GGX
// http://www.filmicworlds.com/2014/04/21/optimizing-ggx-shaders-with-dotlh/
float NDF_GGX( float NdotH, float Roughness )
{
	float Alpha = Roughness * Roughness;
	float AlphaSquared = Alpha * Alpha;
	float Denominator = NdotH * NdotH * ( AlphaSquared - 1.0 ) + 1.0;
	return AlphaSquared / ( PI * Denominator * Denominator );
}

//////////////////////////////////////////////////////////////////////////
// GeometryVisibility_CookTorrence
float GeometryVisibility_CookTorrence( float NdotL, float NdotV, float NdotH, float VdotH )
{
	float G = 1.0;
	G = min( G, ( 2.0 * NdotH * NdotV ) / VdotH );
	G = min( G, ( 2.0 * NdotH * NdotL ) / VdotH );
	return G;
}

//////////////////////////////////////////////////////////////////////////
// GeometryVisibility_SmithGGXApprox
// http://www.filmicworlds.com/2014/04/21/optimizing-ggx-shaders-with-dotlh/
float GeometryVisibility_SmithGGXApprox( float LdotH, float Roughness )
{
	float K = ( Roughness * Roughness ) / 2.0;
	float KSquared = K * K;
	float InvKSquared = 1.0 - KSquared;
	return 1.0 / ( LdotH * LdotH * InvKSquared + KSquared );
}

//////////////////////////////////////////////////////////////////////////
// EnvBRDFApprox
// TODO: half.
// https://www.unrealengine.com/blog/physically-based-shading-on-mobile
float3 EnvBRDFApprox( float3 SpecularColor, float Roughness, float NoV )
{
	const float4 c0 = float4( -1, -0.0275, -0.572, 0.022 );
	const float4 c1 = float4( 1, 0.0425, 1.04, -0.04 );
	float4 r = Roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
	float2 AB = float2( -1.04, 1.04 ) * a004 + r.zw;
	return SpecularColor * AB.x + AB.y;
}

//////////////////////////////////////////////////////////////////////////
// BRDF_Default
float3 BRDF_Default( Light InLight, in Material InMaterial, in float3 ViewPosition, in float3 SurfacePosition, in float3 Normal, in float3 ReflectionColour )
{
	// Shared utility.
	float3 LightPosition = InLight.Position_.xyz;
	float3 ViewVector = normalize( ViewPosition - SurfacePosition );
	float3 LightVector = normalize( LightPosition - SurfacePosition );
	float3 HalfVector = normalize( LightVector + ViewVector );
	float NdotL = max( LIGHTING_EPSILON, dot( Normal, LightVector ) );
	float NdotH = max( LIGHTING_EPSILON, dot( Normal, HalfVector ) );
	float NdotV = max( LIGHTING_EPSILON, dot( Normal, ViewVector ) );
	float LdotH = max( LIGHTING_EPSILON, dot( LightVector, HalfVector ) );
	float VdotH = max( LIGHTING_EPSILON, dot( ViewVector, HalfVector ) );

	// Calculate diffuse + spec material colours.
	float3 DielectricSpecular = float3( DIELECTRIC_F0, DIELECTRIC_F0, DIELECTRIC_F0 );
	float3 MaterialDiffuse = ( InMaterial.Colour_ - InMaterial.Colour_ * InMaterial.Metallic_ );
	float3 MaterialSpecular = lerp( DielectricSpecular, InMaterial.Colour_, InMaterial.Metallic_ );

	// Calculate terms for spec + diffuse.
#if USE_SPECULAR_BLINN_PHONG
	float D = NDF_BlinnPhongNormalised( NdotH, RoughnessToSpecularPower( InMaterial.Roughness_ ) );
	float G = GeometryVisibility_CookTorrence( NdotL, NdotV, NdotH, VdotH );
	float3 Fspec = Fresnel_SchlickApproximation( MaterialSpecular, LdotH );
	float3 SpecularColour = Fspec * D * G;
#elif USE_SPECULAR_GGX
	float D = NDF_GGX( NdotH, InMaterial.Roughness_ );
	float G = GeometryVisibility_SmithGGXApprox( LdotH, InMaterial.Roughness_ );
	float3 Fspec = Fresnel_SchlickApproximation( MaterialSpecular, LdotH );
	float3 SpecularColour = Fspec * D * G;
#else
#  error No other specular model supported.
#endif

	// Diffuse
#if USE_DIFFUSE_LAMBERT
	float INV_PI = 1.0 / PI;
	float3 DiffuseColour = float3( INV_PI, INV_PI, INV_PI );
	DiffuseColour *= MaterialDiffuse;
#else
#  error No other diffuse model supported.
#endif

	// Total colour.
	float3 Total = DiffuseColour + SpecularColour;

	// Punctual light source.
	Total = Total * InLight.Colour_ * NdotL;

	// Reflection. TODO: Factor out of here.
	Total += ReflectionColour * EnvBRDFApprox( MaterialSpecular, InMaterial.Roughness_, NdotV );

	return Total;
}

#endif // __PSYBRUSLIGHTING_PSH__
