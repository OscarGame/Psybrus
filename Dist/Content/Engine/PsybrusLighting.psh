#ifndef __PSYBRUSLIGHTING_PSH__
#define __PSYBRUSLIGHTING_PSH__

// Generated header.
#include <UniformLight.psh>

#define USE_SPECULAR_BLINN_PHONG ( 0 )
#define USE_SPECULAR_GGX ( 1 )
#define USE_DIFFUSE_LAMBERT ( 1 )

#define LIGHTING_EPSILON  ( 1e-6 )
#define DIELECTRIC_F0 ( 0.04 )

//////////////////////////////////////////////////////////////////////////
// Light
struct Light
{
	float3 Position_;
	float3 Colour_;
	float3 AttenuationCLQ_;
};

//////////////////////////////////////////////////////////////////////////
// Material
struct Material
{
	float3 Colour_;
	float Roughness_;
	float Metallic_;
};

//////////////////////////////////////////////////////////////////////////
// Pow5
float Pow5( float Val )
{
	return Val * Val * Val * Val * Val;
}

//////////////////////////////////////////////////////////////////////////
// calculateAttenuation
float calculateAttenuation( float Distance, float3 Attenuation )
{
	float InvA = ( ( Attenuation.x + ( Distance * Attenuation.y ) + ( Distance * Distance * Attenuation.z ) ) );
	return 1.0 / InvA;
}

//////////////////////////////////////////////////////////////////////////
// RoughnessToSpecularPower
float RoughnessToSpecularPower( float Roughness )
{
	return 1024.0 * Pow5( 1.0 - Roughness ) + 1.0;
}

//////////////////////////////////////////////////////////////////////////
// Fresnel_SchlickApproximation

float3 Fresnel_SchlickApproximation( float3 F0, float CosA )
{
	float Pow5OneMinusCosA = Pow5( 1.0 - CosA );
	return F0 + ( float3( 1.0, 1.0, 1.0 ) - F0 ) * Pow5OneMinusCosA;
}

//////////////////////////////////////////////////////////////////////////
// NDF_BlinnPhongNormalised
// Equation 19: https://dl.dropboxusercontent.com/u/55891920/papers/mm_brdf.pdf
float NDF_BlinnPhongNormalised( float NdotH, float N )
{
	float NormTerm = ( N + 2.0 ) / ( PIMUL2 );
	float SpecTerm = pow( max( 0.0, NdotH ), N );
	return NormTerm * SpecTerm;
}
//////////////////////////////////////////////////////////////////////////
// NDF_GGX
// http://www.filmicworlds.com/2014/04/21/optimizing-ggx-shaders-with-dotlh/
float NDF_GGX( float NdotH, float Roughness )
{
	float Alpha = Roughness * Roughness;
	float AlphaSquared = Alpha * Alpha;
	float Denominator = NdotH * NdotH * ( AlphaSquared - 1.0 ) + 1.0;
	return AlphaSquared / ( PI * Denominator * Denominator );
}

//////////////////////////////////////////////////////////////////////////
// GeometryVisibility_CookTorrence
float GeometryVisibility_CookTorrence( float NdotL, float NdotV, float NdotH, float VdotH )
{
	float G = 1.0;
	G = min( G, ( 2.0 * NdotH * NdotV ) / VdotH );
	G = min( G, ( 2.0 * NdotH * NdotL ) / VdotH );
	return G;
}

//////////////////////////////////////////////////////////////////////////
// GeometryVisibility_SmithGGXApprox
// http://www.filmicworlds.com/2014/04/21/optimizing-ggx-shaders-with-dotlh/
float GeometryVisibility_SmithGGXApprox( float LdotH, float Roughness )
{
	float K = ( Roughness * Roughness ) / 2.0;
	float KSquared = K * K;
	float InvKSquared = 1.0 - KSquared;
	return 1.0 / ( LdotH * LdotH * InvKSquared + KSquared );
}

//////////////////////////////////////////////////////////////////////////
// CookTorrence
float3 CookTorrence( float D, float3 F, float G, float NdotL, float NdotV )
{
	float3 Numerator = float3( D * F * G );
	float Denominator = 4.0  * NdotL * NdotV;
	return Numerator / Denominator;
}

//////////////////////////////////////////////////////////////////////////
// BRDF_Default
float3 BRDF_Default( Light InLight, in Material InMaterial, in float3 ViewPosition, in float3 SurfacePosition, in float3 Normal, in float3 ReflectionColour )
{
	float3 LightPosition = InLight.Position_.xyz;
	float3 ViewVector = normalize( ViewPosition - SurfacePosition );
	float3 LightVector = normalize( LightPosition - SurfacePosition );
	float3 HalfVector = normalize( LightVector + ViewVector );
	float NdotL = max( LIGHTING_EPSILON, dot( Normal, LightVector ) );
	float NdotH = max( LIGHTING_EPSILON, dot( Normal, HalfVector ) );
	float NdotV = max( LIGHTING_EPSILON, dot( Normal, ViewVector ) );
	float LdotH = max( LIGHTING_EPSILON, dot( LightVector, HalfVector ) );
	float VdotH = max( LIGHTING_EPSILON, dot( ViewVector, HalfVector ) );

	// Convert roughness to specular power.
	float Roughness = InMaterial.Roughness_;

	// Calculate reflectance.
	//float3 BaseF0 = float3( InMaterial.Specular_, InMaterial.Specular_, InMaterial.Specular_ );
	float3 BaseF0 = float3( DIELECTRIC_F0, DIELECTRIC_F0, DIELECTRIC_F0 );
	float3 F0 = lerp( BaseF0, InMaterial.Colour_, InMaterial.Metallic_ ); 

	// Calculate terms for spec + diffuse.
#if USE_SPECULAR_BLINN_PHONG
	float D = NDF_BlinnPhongNormalised( NdotH, RoughnessToSpecularPower( Roughness ) );
	float G = GeometryVisibility_CookTorrence( NdotL, NdotV, NdotH, VdotH );
	float3 Fspec = Fresnel_SchlickApproximation( F0, LdotH );
	float3 SpecularColour = CookTorrence( D, Fspec, G, NdotL, NdotV );
#elif USE_SPECULAR_GGX
	float D = NDF_GGX( NdotH, Roughness );
	float G = GeometryVisibility_SmithGGXApprox( LdotH, Roughness );
	float3 Fspec = Fresnel_SchlickApproximation( F0, LdotH );
	float3 SpecularColour = D * Fspec *  G * NdotL;
#endif

	// Diffuse
#if USE_DIFFUSE_LAMBERT
	float DiffuseScalar = max( NdotL, 0.0 );
	float3 DiffuseColour = float3( DiffuseScalar, DiffuseScalar, DiffuseScalar ) - SpecularColour;
	DiffuseColour = max( float3( 0.0, 0.0, 0.0 ), DiffuseColour * ( float3( 1.0, 1.0, 1.0 ) - float3( InMaterial.Metallic_, InMaterial.Metallic_, InMaterial.Metallic_ ) ) );
	DiffuseColour *= InMaterial.Colour_ / PI;
#endif

	// Reflection. TODO: Factor out of here?
	float GrazingTerm = clamp( ( 1.0 - Roughness ) + InMaterial.Metallic_, 0.0, 1.0 );
	SpecularColour += ReflectionColour * lerp( InMaterial.Colour_, float3( GrazingTerm, GrazingTerm, GrazingTerm ), Pow5( 1.0 - NdotV ) );

	// Total colour.
	float3 Total = DiffuseColour + SpecularColour;

	// Punctual light source.
	return Total * InLight.Colour_ * NdotL;
}

#endif // __PSYBRUSLIGHTING_PSH__
